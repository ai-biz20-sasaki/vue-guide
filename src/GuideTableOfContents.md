## Getting Started | 入門

### Introduction | はじめに
- Vue とは？  
  Vue が備える次の 2 つのコア機能
  - 宣言的レンダリング  
  - リアクティビティー  
- プログレッシブフレームワーク 
- 単一ファイルコンポーネント
- 2 つの API スタイル  
  - Options API
  - Composision API
- さらに知りたいことはありますか？
- 学習方法を選びましょう

### Quick Start | クイックスタート
- オンラインで Vue を試す
- Vue アプリケーションの作成
- CDN の Vue を使用する
- 次のステップ

## Essentials | 基本

### Creating an Application | アプリケーションの作成
- アプリケーションのインスタンス
- ルートコンポーネント
- アプリのマウント
- アプリの設定
- 複数のアプリケーションのインスタンス
### Template Syntax | テンプレート構文
- テキスト展開
- 生の HTML
- 属性バインディング
- JavaScript の式を用いる
- ディレクティブ

### Reactivity Fundamentals | 理アクティビティーの基礎
- リアクティブな状態を宣言する
  - リアクティブプロキシ vs. 独自
- メソッドの宣言
  - ディープなリアクティビティー
  - DOM 更新のタイミング
  - ステートフルなメソッド

### Computed Properties | 算出プロパティ
- 基本的な例
- 算出プロパティ vs. メソッド
- 書き込み可能な 算出関数
- ベストプラクティス
### Class and Style Bindings | クラスとスタイルのバインディング
- HTML クラスのバインディング
- インラインスタイルのバインディング
### Conditional Rendering | 条件付きレンダリング
- v-if
- v-else
- v-else-if
- &lt;template&gt; に v-if を適用する
- v-show
- v-if vs. v-show
- v-if と v-for
### List Rendering | レストレンダリング
- v-for
- v-for をオブジェクトに適用する
- v-for で範囲を使用する
- &lt;template&gt; に v-for を適用する
- v-for と v-if を組み合わせる場合
- key による状態管理
- v-for をコンポーネントに適用する
- 配列の変更の検出
- フィルタリング/並べ替えの結果を表示
### Event Handling | イベントハンドリング
- イベントの購読
- インラインハンドラー
- メソッドハンドラー
- インラインハンドラー下でのメソッドの呼び出し
- インラインハンドラーのイベント引数へのアクセス
- イベント修飾子
- キー修飾子
- マウスボタン修飾子
### Form Input Bindings | フォーム入力バインディング
- 基本的な使い方
  - テキスト
  - 複数行テキスト
  - チェックボックス
  - ラジオ
  - セレクト
- 値のバインディング
  - チェックボックス
  - ラジオ
  - セレクトオプション
- 修飾子
  - .lazy
  - .number
  - .trim
- コンポーネントの v-model
### Lifecycle Hooks | ライフサイクルフック
- ライフサイクルフックの登録
- ライフサイクルダイアグラム
### Watchers | ウォッチャー
- 基本の例
- ディープ・ウォッチャー
- 即時ウォッチャー
- コールバックが実行されるタイミング
- this.$watch()
- ウォッチャーの停止
### Template Refs | テンプレート参照
- 参照へのアクセス
- v-for の中の参照
- 関数を使った参照
- コンポーネントでの参照
### Components Basics | コンポーネントの基礎
- コンポーネントの定義
- コンポーネントの使用
- props の受け渡し
- イベントの購読
- スロットを使ったコンテンツ配信
- 動的コンポーネント
- DOM テンプレート解析の注意点
## Components In-Depth | コンポーネントの詳細
### Registration | 登録
- グローバル登録
- ローカル登録
- コンポーネント名での大文字・小文字の使い方
### Props | プロパティ
- 現在のページの目次
- props の宣言
- props 渡しの詳細
- 一方向のデータフロー
- props のバリデーション
- 真偽値の型変換
### Events | イベント
- イベントの発行と購読
- イベントの引数
- 発行するイベントの宣言
- イベントのバリデーション
### Component v-model | コンポーネントのv-model
- v-model の引数
- 複数の v-model のバインディング
- v-model 修飾子の処理
### Fallthrough Attributes | フォールスルー属性
- 属性の継承
  - class と style のマージ
  - v-on リスナーの継承
  - ネストされたコンポーネントの継承
- 属性の継承の無効化
- 複数のルートノードでの属性継承
- JavaScript 内でフォールスルー属性にアクセスする
### Slots | スロット
- スロットコンテンツとスロットアウトレット
- レンダースコープ
- フォールバックコンテンツ
- 名前付きスロット
- 動的なスロットの名前
- スコープ付きスロット
### Provide / inject | Provide / inject
- props のバケツリレー（Prop Drilling）
- Provide
- アプリケーションレベルの Provide
- Inject
- リアクティビティーと共に利用する
- シンボルキーと共に利用する
### Async Components | 非同期コンポーネント
- 基本的な使い方
- ローディングとエラーの状態
- Suspense とともに使用する
## Reusability | 再利用性

### Composables | コンポーザブル
- 「コンポーザブル」とは？
- マウストラッカーの例
- 非同期の状態の例
- 慣例とベストプラクティス
- コード整理のためのコンポーザブル抽出
- Options API でコンポーザブルを使う
- 他の手法との比較
- 参考文献

### Custom Directives | カスタムディレクテブ
- はじめに
- ディレクティブフック
- 関数のショートハンド
- オブジェクトリテラル
- コンポーネントでの使い方
### Plugins | プラグイン
- はじめに
- プラグインの書き方
## Built-in Components | 組み込みコンポーネント

### Transition | トランジション
- &lt;Transition&gt; コンポーネント
- CSS でのトランジション
- JavaScript フック
- トランジションの再利用
- 出現時のトランジション
- 要素間のトランジション
- トランジションモード
- コンポーネント間のトランジション
- 動的トランジション
### TransitionGroup | トランジショングループ
- &lt;Transition&gt; との違い
- Enter / Leave トランジション
- 移動のトランジション
- 時差をもたせたリストのトランジション
### KeepAlive | KeepAlive
- 基本的な使い方
- Include / Exclude
- キャッシュインスタンスの最大数
- キャッシュされたインスタンスのライフサイクル
### Teleport | Teleport
- 基本的な使い方
- コンポーネントと一緒に使う
- Teleport を無効化する
- 同じターゲットに複数の Teleport
### Suspense | Suspense
- 非同期な依存関係
  - async setup()
  - 非同期コンポーネント
- ローディング状態
- イベント
- エラーハンドリング
- 他のコンポーネントとの組み合わせ
## Scaling Up | スケールアップ

### Single-File Components | 単一ファイルコンポーネント(SFC)
- はじめに
- なぜ SFC なのか
- 仕組み
- 関心の分離についてはどうですか？
### Tooling | ツール
- オンラインで試す
- プロジェクトの雛形の作成 (Project Scaffolding)
- IDE のサポート
- ブラウザーの開発者ツール
- TypeScript
- テスト
- リント
- コードフォーマット
- SFC カスタムブロック統合
- 低レベルのパッケージ群
- その他のオンラインプレイグラウンド
### Routing | ルーティング
- クライアントサイドとサーバーサイドのルーティングの比較
- 公式ルーター
- スクラッチでのシンプルなルーティング
### State Management | 状態管理
- 状態の管理とは何か ?
- リアクティビティー API によるシンプルな状態の管理
- SSR の考慮
- Pinia
### Testing | テスト
- なぜテストをするのか？
- いつテストをするか？
- テストの種類
- 概要
- 単体テスト
- コンポーネントのテスト
- E2E テスト
- レシピ
### Server-Side Rendering (SSR) | サーバーサイドレンダリング(SSR)
- 概要
  - SSR とは？
  - なぜ SSR なのか？
  - SSR vs. SSG
- 基本チュートリアル
  - アプリケーションのレンダリング
  - クライアント・ハイドレーション
  - コード構造
- より高度な解決法
  - Nuxt
  - Quasar
  - Vite SSR
- SSR フレンドリーなコードを書く
  - サーバー上でのリアクティビティー
  - コンポーネントのライフサイクルフック
  - 特定のプラットフォームの API にアクセスする
  - クロスリクエスト状態汚染
  - ハイドレーション・ミスマッチ
  - カスタムディレクティブ
  - テレポート
## Best Practices | ベストプラクティス

### Production Deployment | 本番デプロイ
- 開発と本番の違い
- ビルドツールなし
- ビルドツールあり
- ランタイムエラーの追跡
### Performance | パフォーマンス
- 概要
- プロファイリングのオプション
- ページロード最適化
  - 適切なアーキテクチャの選択
  - バンドルサイズと Tree-shaking
  - コード分割
- 更新の最適化
  - props の安定性
  - v-once
  - v-memo
- 全般的な最適化
  - 大きなリストの仮想化
  - 大きなイミュータブルな構造のリアクティビティーオーバーヘッドを減らす
  - 不必要なコンポーネントの抽象化を避ける
### Accessibility | アクセシビリティ
- スキップリンク
- コンテンツ構成
- セマンティックなフォーム
- 標準規格
- リソース
### Security | セキュリティ
- 脆弱性の報告
- ルール No.1： 信頼できないテンプレートは使わない
- Vue があなたを守るためにしていること
- 潜在的な危険
- ベストプラクティス
- バックエンドとの連携
- サーバーサイドレンダリング (SSR)
## TypeScript | TypeScript

### Overview | 概要
- プロジェクトのセットアップ
  - 概要
  - IDE のサポート
  - tsconfig.json の構成
  - Volar Takeover Mode
  - Vue CLI と ts-loader に関する注意
- 一般的な使用上の注意
  - defineComponent()
  - 単一ファイルコンポーネントでの使用法
  - テンプレート内での TypeScript
  - TSX の使用方法
- ジェネリックコンポーネント
- API 固有のレシピ
### TS with Composition API | Composition APIとTypeScript
- コンポーネント props の型付け
- コンポーネントの emit の型付け
- ref() の型付け
- reactive() の型付け
- computed() の型付け
- イベントハンドラーの型付け
- Provide / Inject の型付け
- テンプレート参照の型付け
- コンポーネントのテンプレート参照の型付
### TS with Options API | Options APIとTypeScript
- コンポーネント props の型付け
- コンポーネントの emits の型付け
- 算出プロパティの型付け
- イベントハンドラーの型付け
- グローバルなプロパティの拡張
- カスタムオプションの拡張
## Extra Topics | 番外トピック

### Ways of Using Vue | Vueのさまざまな活用方法
- スタンドアロンスクリプト
- 組み込み用 Web コンポーネント
- シングルページアプリケーション (SPA)
- フルスタック / サーバーサイドレンダリング (SSR)
- JAMStack / 静的サイトジェネレーション (SSG)
- Web 以外
### Composition API FAQ | Composition APIのFAQ
- Composition API とは？
- なぜ Composition API なのか？
  - より良いロジックの再利用
  - より柔軟なコード整理
  - より良い型推論
  - プロダクションバンドルをより小さく、そしてオーバーヘッドを減らす
- Options API との関係
  - トレードオフ
  - Composition API は全てのユースケースをカバーしていますか？
  - 同じコンポーネント内で両方の API を使用できますか？
  - Options API は非推奨になったのですか？
- Class API との関係
- React Hooks との比較
### Reactivity in Depth | リアクティビティの探求
- リアクティビティーとは？
- Vue におけるリアクティビティーの仕組み
- ランタイムとコンパイルタイムのリアクティビティーの比較
- リアクティビティーのデバッグ
  - コンポーネントデバッグフック
  - 算出プロパティのデバッグ
  - ウォッチャーのデバッグ
- 外部の状態システムとの統合
  - イミュータブルなデータ
  - ステートマシン
  - RxJS
- シグナルとの関連
  - API 設計のトレードオフ
### Rendering Mechanism | レンダリングの仕組み
- 仮想 DOM
- レンダーパイプライン
- テンプレート vs. レンダー関数
- コンパイラー情報に基づく仮想 DOM
  - 静的ホイスティング
  - パッチフラグ
  - ツリーのフラット化
  - SSR ハイドレーションへの影響
### Render Functions & JSX | レンダー関数とJSX
- 基本的な使い方
  - vnode の作成
  - レンダー関数の宣言
  - Vnode は一意でなければならない
- JSX / TSX
  - JSX 型推論
- レンダー関数のレシピ
  - v-if
  - v-for
  - v-on
  - コンポーネント
  - スロットのレンダリング
  - スロットの渡し方
  - 組み込みコンポーネント
  - v-model
  - カスタムディレクティブ
  - テンプレート参照
- 関数型コンポーネント
  - 関数型コンポーネントの型付け
### Vue and Web Components | VueとWebコンポーネント
- Vue でカスタム要素を使う
- Vue によるカスタム要素のビルド
- Web コンポーネント と Vue コンポーネントの比較
### Animation Techniques | アニメーションテクニック
- クラスベースのアニメーション
- 状態駆動アニメーション
- ウォッチャーを使ったアニメーション